# 4 - Импорт, модули, пакеты, области видимости переменных

## Список тем:

- **Области видимости переменных:** LEGB, `global`, `nonlocal`, Scope v/s Namespace, `globals()`, `dir()`, `locals()`, `if __name__ is '__main__'`, компиляция  
- **Other**: "моржик", `func.__code__.co_varnames`,  
- **Замыкания (closure)**: что такое, примеры, где хранятся? Почему о них идёт речь? `free variables`, достаньте замыкание: имя и значение.
- **Импорт**:` __init__.py`, `__all__` & `non public` сущности , `__import__`, абсолютные и относительные, где лежат используемые библиотеки? `sys.modules`  
- **APT/python-apt, PIP**: где лежат используемые библиотеки? `apt.Cache()`: /var/cache/apt/archives/; `cache.update()`: /etc/apt/sources.list, /var/lib/apt/lists/; Установка пакетов, подсчёт их количества; /usr/lib/python3.10 v/s /usr/lib/python3/dist-package v/s /usr/local/lib/python3.10/dist-packages; как посмотреть локацию модуля из RunTime; `__pycache__`; pip и gcc; pip и cache ~/.cache/pip; `!pip show pip`; `!pip list`; `pip cache purge`; `pip install module_name --no-cache-dir`;  
- **Интерактивный интерпретатор и GoogleColab (GCo)**: запустите интерактивный Python-интерпретатор из GCo.  
- **sys:** путь к исполняемому файлу; `sys.argv`; `sys.exit()`; `sys.path` & `sys.modules`; `sys.version`; `sys.version_info`: `major`, `minor`, `micro`, `releaselevel`, `serial`; `sys.platform`; `sys.modules`: `sys.modules['math']` v/s `sys.modules['pandas']`, `sys.modules` & `import`; `sys.getsizeof(object)` v/s `object.__sizeof__()`; `sys.getrefcount(object)`;  
- **Modules**: `builtins` & `__builtin__` & `__builtins__`, importlib. Как посмотреть версию модуля? `__name__ ` 
- **importlib**: `.reload(...)` & `sys.modules`, `%%writefile _my_module.py` & `.import_module('...')` & `sys.modules`,  
- **Структура проекта:** `__init__.py`, `__all__`, `__doc__`, `__annotations__`
___________

## Область видимости переменных

**Области видимости (scope) и пространства имен (namespace)** – концепции по управлению переменными и их видимостью.

### Scope

**Scope** – определяет, в каких частях программы переменная доступна для использования:
- **Local** – переменные, объявленные в функции. Видимы только внутри этой функции.
- **Enclosed** – переменные из внешних (но не глобальных) функций: вложенные функции.
- **Global** – переменные, доступные во всем модуле.
- **Built-in** – переменные, предопределенные Python.

**LEGB** – модель, по которой осуществляется поиск переменной.

Рассмотрим пример для наглядности:

```Python
x = "global"

def outer_func():
    x = "enclosed"

    def inner_func():
        x = "local"
        print(x)

    inner_func()

outer_func() # local
```

`x` определена на трех уровнях: Global, Enclosed и Local.

Вызов `inner_function()`, поиск `x`:
1. *в Local*: внутри `inner_function`
2. *в Enclosed*: внутри `outer_function`
3. *в Global*

*Также можем задать больший scope переменной из* подпространства.
В примере: `global` x говорит, что x внутри ф-и ссылается на глобальную переменную.

```Python
x = "global"

def change_global():
    global x
    x = "modified global"

change_global()
print(x) # modified_global
```

*Также можем задать больший scope переменной из* подпространства.
В примере: `nonlocal` x изменяет значение x в области видимости `outer_function`.

```python
def outer_func():
    x = "enclosed"

    def inner_func():
        nonlocal x
        x = "modified enclosed"

    inner_func()
    print(x)

outer_func() # modified enclosed
```

Вот демонстрация для всего блока про Scopes:

```Python
def scope_test():  
    def do_local():  
        spam = "local spam"  
  
    def do_nonlocal():  
        nonlocal spam  
        spam = "nonlocal spam"  
  
    def do_global():  
        global spam  
        spam = "global spam"  
  
    spam = "test spam"  
    do_local()  
    print("After local assignment:", spam)  
    do_nonlocal()  
    print("After nonlocal assignment:", spam)  
    do_global()  
    print("After global assignment:", spam)  
  
scope_test()  
print("In global scope:", spam)
```
```output
After local assignment: test spam
After nonlocal assignment: nonlocal spam
After global assignment: nonlocal spam
In global scope: global spam
```

### Namespace

**namespace** — отображение имен (например, переменных и функций) на объекты. Можно думать о namespace как о словаре, где ключами являются имена переменных, а значениями — их данные. *Namespaces* создаются в следующих случаях:
- Когда **загружается модуль**: создается *глобальное namespace*.
- Когда **вызывается функция**: создается *локальное namespace*.
- Когда **интерпретатор запускается**: создается *встроенное namespace*.

*В примере:* переменная `a` находится в **global namespace** и доступна из ф-и, тогда как `b` существует только внутри функции: **local namespace**.
```Python
a = 5  
  
def my_function():  
    b = 10  
    print(a)  
  
my_function()  # 5
print(b) # NameError: name 'b' is not defined
```

### `scopes()`, `globals()`, `dir()`

Функция **globals()** возвращает словарь всех переменных в глобальной области видимости текущего модуля.
Функция **dir()** возвращает список всех доступных имён в текущей области видимости или атрибутов объекта, если передан аргумент.
Функция **locals()** возвращает словарь локальных переменных текущей области видимости.

```Python
x = 42  
y = 'hello'  
  
def demo_scope(a, b):  
    local_var = a + b  
    hidden = "secret"  
  
    print("=== LOCALS ===")  
    for name, value in locals().items():  
        print(f"{name} -> {value}")  
  
    print("\n=== GLOBALS ===")  
    print(f"x in globals: {'x' in globals()}")  
    print(f"y in globals: {'y' in globals()}")  
    print(f"local_var in globals: {'local_var' in globals()}")  
  
    print("\n=== DIR ===")  
    print("Available names:", dir())  
  
demo_scope(10, 5)
```
```output
=== LOCALS ===
a -> 10
b -> 5
local_var -> 15
hidden -> secret

=== GLOBALS ===
x in globals: True
y in globals: True
local_var in globals: False

=== DIR ===
Available names: ['a', 'b', 'hidden', 'local_var', 'name', 'value']
```

### `if __name__ == '__main__'`

Конструкция `if __name__ == '__main__'`: проверяет, запущен ли модуль как основной файл, а не импортирован. Переменная __name__ равна "__main__" , если модуль запущен напрямую.
### Компиляция

*Компиляция в Python* – это процесс преобразования исходного кода в байт-код ( .pyc - файлы), который затем исполняется виртуальной машиной Python (PVM). Компиляция происходит автоматически при запуске или импорте модуля.

_____________
## Оператор "моржик" и `func.__code__.co_varnames`

Оператор `:=` , известный как "моржик", позволяет присваивать значение переменной внутри выражения. (Доступен с Python 3.8.)

```Python
WALRUS = "I am the walrus, goo goo goo joob"  
  
if (n := len(WALRUS)) > 3:  
    print(n)  # 33
    print("I am the walrus, goo goo goo joob goo goo goo joob")
```
	from song "I Am the Walrus" by The Beatles


Атрибут `func.__code__.co_varnames` возвращает кортеж имён всех локальных переменных функции.

```Python
def foo(a, b):  
    c = a + b  
    return c  
  
print(foo.__code__.co_varnames) # ('a', 'b', 'c')
```

_______________
## Замыкания (closure)

**Замыкание (closure)** — это функция, которая сохраняет доступ к переменным из своей окружающей области видимости (другая функция), даже после того, как эта другая функция завершила выполнение.
Замыкания создаются, когда вложенная функция сохраняет ссылки на переменные (использует их), которые не определены внутри нее, но доступны в ее вложенной области видимости.

```Python
def outer_function(msg):
    # msg из области видимости outer_function
    def inner_function():
        print(msg)
    return inner_function

my_closure = outer_function("Hello, Closure!")
my_closure() # Hello, Closure!
```
	 Переменная msg доступна для inner_function, несмотря на то, что outer_function уже завершилась.

*Замыкания полезны для создания функций с "памятью"*, используются в декораторах, фабриках функций и для инкапсуляции данных.

**Чем опасны замыкания?**
- Сложно уследить, что функция утаскивает в своё замыкание и где обитают переменные, попавшие в замыкание функции.
- Утечка памяти: можем в scope хранить большие объекты и они не будут удалены, пока не будет уничтожено замыкание.

### Где хранятся?

Замыкания хранятся в атрибуте `__closure__` функции, который содержит кортеж объектов cell с "свободными переменными" – free variables.

```Python
print(my_closure.__closure__)  # (<cell at 0x00000205BBC10610: str object at 0x00000205BBC43AF0>,)
print(my_closure.__closure__[0].cell_contents) # Hello, Closure!
```

Свободные переменные (free variables) — это переменные, которые используются в замыкании, но определены во внешней функции.
```Python
print(my_closure.__code__.co_freevars) # ('msg',)
```

### Как достать имя и значение замыкания?

Из прошлого пункта помним:
- `func.__code__.co_freevars` — кортеж имён свободных переменных (т.е. *имена переменных*, которые используются внутри, но определены снаружи).
- `func.__closure__` — кортеж *cell-объектов*, каждый из которых содержит значение соответствующей переменной.
```Python
def outer_function(msg):  
    # msg из области видимости outer_function  
    def inner_function():  
        print(msg)  
    return inner_function  
  
my_closure = outer_function("Hello, Closure!")  

name = my_closure.__code__.co_freevars[0]  
value = my_closure.__closure__[0].cell_contents  
  
print(f"{name} = {value}") # msg = Hello, Closure!
```

Имена и значения идут **в одинаковом порядке** в этих двух структурах, поэтому можно использовать `zip()`.

```Python
for name, cell in zip(my_closure.__code__.co_freevars, my_closure.__closure__):
    print(f"{name} = {cell.cell_contents}")
```
