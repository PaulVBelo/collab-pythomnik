# 2 - Простое ООП

## Список тем:

- **Класс, методы, инстансы, атрибуты**, `self`, `@classmethod`, `@staticmethod`, фабричные методы. Как получить имя и атрибуты класса? 
- **pyhton objects**: links, mutable / immutable, хэш объектов, аллокация в памяти, как посмотреть тип объекта, создание своих типов, структура разных типов. 
- ***dunder methods***: `__init__`, `__repr__` v/s `__str__`, `__len__`, `__call__`, `__add__`, `__sub__`, `__mul__`, `__truediv__`, object и причём тут 'Сахар'?
- **Инкапсуляция**, name mangling, геттеры и сеттеры, граница архитектуры, `@property`
- **Наследование**: всегда ли оно используется? Для чего оно используется? множественное, иерархическое, `super`, переопределение `@property`
- **Полиморфизм**
- `__dir__()` v/s `__dict__ v/s` `var()`, `help`, `__class__`, `id`, `hex`
__________
ООП – это парадигма, где используются объекты и классы для структуры кода.
_________
## ***Класс, методы, инстансы, атрибуты***

- **Класс** – это шаблон (чертёж) для создания объектов (экземпляров), включает методы и атрибуты.
- **Инстансы** – объекты, созданные по шаблону класса.

```Python
class Car:  
    wheels = 4 # Атрибут класса  
  
    def __init__(self, color, brand): # dunder method  
        # Атрибуты экземпляра        self.color = color  
        self.brand = brand  
  
    def start_engine(self): # method  
        print(f"{self.color} {self.brand}: engine started")  
  
    @classmethod  
    def change_wheels(cls, number):  # class method  
        cls.wheels = number  
  
    @staticmethod  
    def miles_to_km(miles): # static method  
        return 1.6 * miles  
  
    @classmethod  
    def from_str(cls, string): # Фарбричный метод  
        model, color = string.split(' ')  
        return cls(model, color)  
  
  
my_сar = Car('Black', 'Toyota') # Инстанс  
my_сar.start_engine()
```

#### Атрибуты:
 переменные класса/экземпляра, которые хранят данные. **Атрибуты** могут быть:
-  **класса** (общими для всех экземпляров):
	- *Экономия памяти:* Хранятся единообразно и разделяются между экземплярами, снижая использование ресурсов.
	- *Общее состояние:* Позволяют задать свойства, общие для всех объектов .
- **экземпляра** (уникальными для каждого объекта).

#### Методы:

*Методы* - функции внутри класса, которые описывают поведение объектов.

- **Методы экземпляра**: работают с экземпляром класса. Принимает `self` как первый аргумент — это ссылка на сам объект (экземпляр).
- **Методы класса**: работают с самим классом:
	- Используют декоратор `@classmethod`
	- Принимают в качестве первого параметра ссылку на класс `cls`, а не на экземпляр `self`. Это позволяет методам класса *обращаться к атрибутам класса и изменять их*.
	- ***Создание фабричных методов**:* Для создания новых объектов этого класса или его подклассов. Позволяют инкапсулировать логику создания объектов и делают код более гибким и расширяемым.
	- *Доп. функциональность:* Создание методов, которые логически связаны с классом, но не зависят от конкретного экземпляра.
- **Статические методы**: обычные функции, логически связанные с классом:
	- Использую декоратор `@staticmethod`
	- Не могут изменять или получать доступ к атрибутам и методам класса или экземпляра.
	- *Организация кода:* Реализуют функции, связанные с классом, но не зависят от его данных.
	- *Снижение зависимости*: Предоставляют функциональность, не зависящую от состояния объектов и класса.
- **Специальные методы / Магические методы / dunder (double underscore) методы**: используются для определения поведения объектов в специфических сценариях (см. в пунктах про них)

### Как получить имя и атрибуты класса? 

- `__class__` – ссылка на класс объекта.
- `__name__` – имя класса в виде строки.
- `__dict__` объекта – словарь всех *атрибутов экземпляра (т.е. установленных через `self` в `init`).
- `__dict__` класса – словарь всех *атрибутов класса*, методов, служебных полей.
- `dir()` — универсальный способ посмотреть **всё**, включая магические методы и пользовательские поля.

```Python
car = Car('Green', 'Toyota'"')

# Имя класса
print(car.__class__.__name__)  # Car

# Все атрибуты экземпляра (в словаре)
print(car.__dict__)  # {'brand': 'Toyota'}

# Все атрибуты класса и методы
print(dir(Car))  # список всех имен (вкл. методы, свойства и т.д.)

# Атрибуты класса отдельно
print(Car.__dict__)  # словарь с атрибутами и методами класса
```
```Output
Car
{'color': 'Green', 'brand': 'Toyota'}
['__class__', '__delattr__', '__dict__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__getstate__', '__gt__', '__hash__', '__init__', '__init_subclass__', '__le__', '__lt__', '__module__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', '__weakref__', 'change_wheels', 'from_str', 'miles_to_km', 'start_engine', 'wheels']
{'__module__': '__main__', 'wheels': 4, '__init__': <function Car.__init__ at 0x0000023529DCB240>, 'start_engine': <function Car.start_engine at 0x0000023529DCB2E0>, 'change_wheels': <classmethod(<function Car.change_wheels at 0x0000023529DCB380>)>, 'miles_to_km': <staticmethod(<function Car.miles_to_km at 0x0000023529DCB420>)>, 'from_str': <classmethod(<function Car.from_str at 0x0000023529DCB4C0>)>, '__dict__': <attribute '__dict__' of 'Car' objects>, '__weakref__': <attribute '__weakref__' of 'Car' objects>, '__doc__': None}
```

_______
## ***Python objects***

[TODO]

______________
## ***Double Underscore methods (dunders)***

- **Инициализатор/Конструктор класса** `__init__`:
    - Вызывается автоматически при создании объекта и задает значения атрибутам объекта.
    - Если метод не определен, Python использует метод по умолчанию, поскольку класс наследуется от `object`.
    
- **`__str__`**:
	- Преобразование в строку.
    - Должен быть простым и понятным для конечных пользователей, а не только для разработчиков.
    - Вызывается: `obj.__str__()`, `str()`, `print()`, `str.format()` или f-строк.
- **`__repr__`**:
    - Используется для отладки и разработки.
    - (Хорошо, если) для однозначного восстановления объекта с помощью `eval()`.
    - Вызывается: `obj.__repr__()`, `repr()`, в интерпретаторе или в методах IPython.
    - Используется, если `__str__` явно не объявлен.
    
- **`__len__`**:
    - Позволяет объекту определять свою длину.
    - Вызывается с помощью: `obj.__len__()`, `len(obj)`
    
- **`__call__`**:
    - Позволяет вызывать экземпляр класса как функцию.
    - Вызывается с помощью: `obj.__call__()`, `obj()`
    
- **`__add__`**: переопределяет операцию сложения (+)
- **`__sub__`**: переопределяет операцию вычитания (-)
- **`__mul__`**: переопределяет операцию умножения (*)
- **`__truediv__`**: переопределяет операцию деления (/)

Рассмотрим часть из них на примере класса дроби Ratio:
```Python
from math import gcd  
  
class Ratio:  
    def __init__(self, num=0, den=1):  
        if den == 0:  
            raise ValueError("Denominator cannot be zero.")  
        self.num = num  
        self.den = den  
        self._reduce()  
  
    def _reduce(self):  
        common = gcd(self.num, self.den)  
        self.num //= common  
        self.den //= common  
        if self.den < 0:  
            self.num *= -1  
            self.den *= -1  
  
    def __repr__(self):  
        return f"Rational(num={self.num}, den={self.den})"  
  
    def __str__(self):  
        return f"{self.num}/{self.den}"  
  
    def __add__(self, other):  
        if not isinstance(other, Ratio):  
            other = Ratio(other)  
        lcm = self._lcm(self.den, other.den)  
        num = self.num * (lcm // self.den) + other.num * (lcm // other.den)  
        return Ratio(num, lcm)  
  
    def __sub__(self, other):  
        return self + (-other)  
  
    def __neg__(self):  
        return Ratio(-self.num, self.den)  
  
    def __mul__(self, other):  
        if not isinstance(other, Ratio):  
            other = Ratio(other)  
        return Ratio(self.num * other.num, self.den * other.den)  
  
    def __truediv__(self, other):  
        if not isinstance(other, Ratio):  
            other = Ratio(other)  
        return Ratio(self.num * other.den, self.den * other.num)  
  
  
    ## Другие прикольные дандеры  
  
    def __eq__(self, other):  
        return isinstance(other, Ratio) and self.num == other.num and self.den == other.den  
  
    def __lt__(self, other):  
        return self.num * other.den < other.num * self.den  
  
    def __le__(self, other):  
        return self < other or self == other  
  
    def __gt__(self, other):  
        return not self <= other  
  
    def __ge__(self, other):  
        return not self < other  
  
    def __float__(self):  
        return self.num / self.den  
  
    @staticmethod  
    def _lcm(a, b):  
        return abs(a * b) // gcd(a, b)  
  
a = Ratio(2, 3)  
b = Ratio(1, 6)  
  
print(a + b)       # 5/6  
print(a * b)       # 1/9  
print(a - b)       # 1/2  
print(a / b)       # 4/1  
print(float(a))    # 0.666...  
print(a == Ratio(4, 6))  # True
```

А вот пример использования `__call__` и `__len__` в классе Sentence:
```Python
class Sentence:
    def __init__(self, text):
        self.text = text
        self.words = self.text.split()

    def __len__(self):
        return len(self.words)

    def __call__(self, func):
        return [func(w) for w in self.words]

sentence = Sentence("Hello world!")
print(len(sentence))         # Output: 2
print(sentence(str.upper))  # Output: ['HELLO', 'WORLD!']
print(sentence(len))        # Output: [5, 6]
```
___________
## ***Инкапсуляция***

 ***Инкапсуляция*** – это способ создания понятного и удобного интерфейса для пользователя, который четко показывает, что можно делать с объектом. Это позволяет разработчику гарантировать, что внутренние детали реализации скрыты и защищены от некорректного использования, что снижает вероятность поломок.
 
- **Защита данных**: Инкапсуляция скрывает внутреннее представление объекта, защищая его от нежелательных изменений. Приватные атрибуты ограничивают доступ к конфиденциальным данным, позволяя использовать методы для проверки безопасности.
- **Снижение сложности**: Инкапсуляция предоставляет только необходимые части объекта. Пользователи класса не должны беспокоиться о внутренних деталях реализации. Это упрощает использование и понимание объекта.
- **Гибкость**: Разработчик может изменить способ хранения или обработки данных внутри класса, но методы доступа (геттеры и сеттеры) остаются прежними для других частей программы. Это позволяет изменять реализацию без нарушения работы API.
- **Контроль над данными**: Методы могут накладывать правила доступа и проверки, гарантируя корректность значений атрибутов.

***Лучшие практики:***
- **Баланс инкапсуляции и доступности**: Чрезмерная инкапсуляция может привести к сложному и трудно поддерживаемому коду. Инкапсулируйте только то, что необходимо для защиты целостности объекта.
    - Если после инкапсуляции часть объекта нужно лезть в приватные методы, то стоит задуматься о том, насколько качественно была проведена архитектурная граница.
- **Документирование API**: Четкая документация публичных интерфейсов необходима для эффективного использования инкапсулированных объектов. Это гарантирует, что предполагаемое использование будет понятно другим разработчикам.

### Модификаторы доступа

**Модификаторы доступа** используются для определения видимости и доступности членов класса (атрибутов и методов):
- **public**: Доступен в любом месте (`self.attribute`)
- **protected**: Предназначен для использования внутри класса и его подклассов (`self._attribute`)
- **private**: Недоступен из родительского класса напрямую (`self.__attribute`)

#### Манглирование имён (name mangling):

Python автоматически переименовывает `__name` → `_<ClassName>__name`

```Python
class Secret:     
	def __init__(self):         
		self.__data = 42  

s = Secret() 
print(s._Secret__data)  # 42
```

Это нужно, чтобы *избежать конфликта имён при наследовании*. Это **не защита**, а *способ ограничить случайный доступ.*

### Геттеры и сеттеры

Методы, контролирующие доступ к приватным атрибутам:
- ***Геттер* (аксессор):** Возвращает значение приватного атрибута.
- ***Сеттер* (мутатор):** Устанавливает значение приватного атрибута с проверкой.

```Python
class BankAccount:  
    def __init__(self, owner, balance):  
        self.owner = owner             # Публичный атрибут  
        self.__balance = balance       # Приватный атрибут  
  
    def get_balance(self): # getter  
        return self.__balance  
  
    def set_balance(self, balance): # setter  
        if balance > 0:  
            self.__balance = balance  
        else:  
            raise ValueError("Баланс должен быть положительный")  
  
# Пример использования  
acc = BankAccount("John", 50000)  
print(acc.get_balance())             # Доступ к приватному атрибуту через геттер  
acc.set_balance(60000)               # Изменение приватного атрибута через сеттер  
print(acc.get_balance())             # Проверка нового баланса
```
```Output
50000
60000
```
#### Зачем геттеры и сеттеры?

- **Инкапсуляция:** Скрывает реализацию и контролирует изменение данных.
- **Валидация:** Сеттеры могут включать логику проверки данных перед изменением атрибута.
- **Гибкость:** Если в будущем реализация атрибута изменится (потребуются вычисления или хранение данных в другом формате), можно обновить геттеры и сеттеры, не изменяя код, который их использует.
- **Логирование:** В сеттерах можно добавить логирование или отладочный код для отслеживания, когда и как атрибуты изменяются.

#### @property

Декораторы `@property`, `@<prop>.setter`, `@<prop>.deleter` реализуют Python-style способ управления доступом к данным через *геттеры и сеттеры*, сохраняя синтаксис обращения как к обычному атрибуту.

`@property` позволяет **скрыть реализацию** за простым интерфейсом. Атрибут становится доступен для чтения, записи и удаления, при этом логика может быть произвольной (например, с проверками или кешированием).

Подробнее см. [Stack Overflow](https://stackoverflow.com/questions/17330160/how-does-the-property-decorator-work-in-python), [Documentation](https://docs.python.org/3/library/functions.html#property)

Рассмотрим, как поменяется код при их использовании:

```Python
class BankAccount:  
    def __init__(self, owner, balance):  
        self.owner = owner             # Публичный атрибут  
        self.__balance = balance       # Приватный атрибут  
  
    @property  
    def balance(self): # getter  
        return self.__balance  
  
    @balance.setter  
    def balance(self, balance): # setter  
        if balance > 0:  
            self.__balance = balance  
        else:  
            raise ValueError("Баланс должен быть положительный")  
  
# Пример использования  
acc = BankAccount("John", 50000)  
print(acc.balance)             # Доступ к приватному атрибуту  
acc.balance = 60000            # Изменение приватного атрибута  
print(acc.balance)             # Проверка нового баланса
```
```Output
50000
60000
```

Другой пример:
```Python
class Cube:  
    def __init__(self, edge_length):  
        self.edge_length = edge_length  # вызывает setter  
  
    @property  
    def edge_length(self):  
        return self.__edge_length  
  
    @edge_length.setter  
    def edge_length(self, value):  
        if value <= 0:  
            raise ValueError("Сторона куба должна быть положительной")  
        self.__edge_length = value  
  
    @property  
    def volume(self):  
        return self.__edge_length ** 3  
  
    @property  
    def surface_area(self):  
        return 6 * (self.__edge_length ** 2)  
  
  
c = Cube(3)  
print(c.volume)          # 27  
c.edge_length = 4  
print(c.volume)          # 64
```

______________
## ***Наследование***

[TODO]

## ***Полиморфизм***

[TODO]

______
## ***dict, dir, var, help, class, id, hex***

[TODO]